# МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ БАЛЛИСТИЧЕСКОГО ДВИЖЕНИЯ С УЧЕТОМ СИЛ СОПРОТИВЛЕНИЯ ВОЗДУХА

**Калинин Е.Д.**  
Студент группы ЭФБО-14-25, Институт перспективных технологий и индустрии программ, РТУ МИРЭА

*Аннотация. В работе представлено математическое моделирование движения тела, брошенного под углом к горизонту, с учетом сил сопротивления воздуха. На основе законов Ньютона составлена система дифференциальных уравнений, описывающая динамику движения. Проведен анализ влияния сопротивления среды на траекторию полета, время движения и дальность. Разработана численная модель на языке Python с использованием метода Рунге-Кутты 4-го порядка для решения системы дифференциальных уравнений. Полученные результаты демонстрируют существенное отличие реальной траектории от идеального случая, что имеет важное практическое значение для баллистических расчетов.*

*Ключевые слова: баллистическое движение, сопротивление воздуха, дифференциальные уравнений, численные методы, метод Рунге-Кутты, математическое моделирование*

## Введение

Классическая задача о движении тела, брошенного под углом к горизонту, является фундаментальной в курсе теоретической механики. Однако в реальных условиях движение существенно отличается от идеального случая из-за воздействия сил сопротивления воздуха. Учет этих сил требует применения более сложного математического аппарата и численных методов решения.

Актуальность работы обусловлена необходимостью точного прогнозирования траекторий движения в различных прикладных областях: баллистике, авиации, спортивной механике. Точное моделирование с учетом сопротивления среды позволяет получать более реалистичные результаты по сравнению с упрощенными моделями.

Цель работы: разработка математической модели и численного алгоритма для расчета траектории движения тела с учетом сил сопротивления воздуха, а также анализ влияния различных параметров на характеристики движения.

## Математическая модель

### Основные уравнения движения

Рассмотрим движение материальной точки массой m, брошенной с начальной скоростью v₀ под углом α к горизонту. На тело действуют две силы: сила тяжести F_т = mg и сила сопротивления воздуха F_с.

Сила сопротивления воздуха пропорциональна квадрату скорости и направлена противоположно вектору скорости:
Fc = -½·ρ·C·S·v^2

где:
- ρ - плотность воздуха (1.225 кг/м³ при нормальных условиях)
- C - коэффициент лобового сопротивления
- S - площадь поперечного сечения
- v - вектор скорости

Запишем систему дифференциальных уравнений второго закона Ньютона в проекциях на оси координат:

m·d²x/dt² = -½·ρ·C·S·vₓ·√(vₓ² + vᵧ²)
m·d²y/dt² = -mg - ½·ρ·C·S·vᵧ·√(vₓ² + vᵧ²)

где vₓ = dx/dt, vᵧ = dy/dt

### Приведение к системе уравнений первого порядка

Для численного решения преобразуем систему уравнений второго порядка в систему четырех уравнений первого порядка:

dvₓ/dt = - (k/m)·vₓ·√(vₓ² + vᵧ²)
dvᵧ/dt = -g - (k/m)·vᵧ·√(vₓ² + vᵧ²)
dx/dt = vₓ
dy/dt = vᵧ

где k = ½·ρ·C·S - коэффициент сопротивления

Начальные условия:
vₓ(0) = v₀·cos α
vᵧ(0) = v₀·sin α
x(0) = 0
y(0) = 0

## Численный метод решения

### Метод Рунге-Кутты 4-го порядка

Для решения системы дифференциальных уравнений применяется метод Рунге-Кутты 4-го порядка, обеспечивающий высокую точность вычислений.

Алгоритм для одного шага:
k1ₓ = h·fₓ(t, vₓ, vᵧ)
k1ᵧ = h·fᵧ(t, vₓ, vᵧ)
k1ₓ = h·vₓ
k1ᵧ = h·vᵧ

k2ₓ = h·fₓ(t + h/2, vₓ + k1ₓ/2, vᵧ + k1ᵧ/2)
k2ᵧ = h·fᵧ(t + h/2, vₓ + k1ₓ/2, vᵧ + k1ᵧ/2)
k2ₓ = h·(vₓ + k1ₓ/2)
k2ᵧ = h·(vᵧ + k1ᵧ/2)

k3ₓ = h·fₓ(t + h/2, vₓ + k2ₓ/2, vᵧ + k2ᵧ/2)
k3ᵧ = h·fᵧ(t + h/2, vₓ + k2ₓ/2, vᵧ + k2ᵧ/2)
k3ₓ = h·(vₓ + k2ₓ/2)
k3ᵧ = h·(vᵧ + k2ᵧ/2)

k4ₓ = h·fₓ(t + h, vₓ + k3ₓ, vᵧ + k3ᵧ)
k4ᵧ = h·fᵧ(t + h, vₓ + k3ₓ, vᵧ + k3ᵧ)
k4ₓ = h·(vₓ + k3ₓ)
k4ᵧ = h·(vᵧ + k3ᵧ)

vₓⁿ⁺¹ = vₓⁿ + (k1ₓ + 2k2ₓ + 2k3ₓ + k4ₓ)/6
vᵧⁿ⁺¹ = vᵧⁿ + (k1ᵧ + 2k2ᵧ + 2k3ᵧ + k4ᵧ)/6
xⁿ⁺¹ = xⁿ + (k1ₓ + 2k2ₓ + 2k3ₓ + k4ₓ)/6
yⁿ⁺¹ = yⁿ + (k1ᵧ + 2k2ᵧ + 2k3ᵧ + k4ᵧ)/6

## Результаты и анализ
Сравнительный анализ траекторий
Проведенное моделирование демонстрирует существенные различия между идеальным случаем и движением с учетом сопротивления воздуха:
Форма траектории: Траектория с учетом сопротивления становится несимметричной - восходящая ветвь более крутая и длинная, нисходящая - более пологая и короткая.
Дальность полета: Наблюдается значительное уменьшение дальности полета. Для начальных параметров (v₀ = 50 м/с, α = 45°) снижение составляет примерно 30-40%.
Максимальная высота: Высота подъема также уменьшается, но в меньшей степени, чем дальность.
Время полета: Общее время движения сокращается.

## Анализ скоростных характеристик
Горизонтальная скорость: В отличие от идеального случая, где горизонтальная скорость постоянна, при учете сопротивления она монотонно убывает.
Вертикальная скорость: Изменяется нелинейно, с более быстрым уменьшением на восходящем участке.
Полная скорость: Постоянно уменьшается в течение всего полета.

## Выводы
Разработана математическая модель баллистического движения с учетом сил сопротивления воздуха, основанная на системе дифференциальных уравнений второго порядка.
Реализован численный алгоритм решения системы уравнений методом Рунге-Кутты 4-го порядка, обеспечивающий высокую точность вычислений.
Проведен сравнительный анализ движения с учетом сопротивления воздуха и идеального случая, выявлены существенные количественные и качественные различия.
Установлено, что сопротивление воздуха приводит к:
Уменьшению дальности полета на 30-40%
Несимметричности траектории
Постоянному уменьшению полной скорости
Сокращению времени полета

## Заключение
Представленная математическая модель адекватно описывает реальное движение тела в воздушной среде и может быть использована для практических расчетов в баллистике, авиации и других областях. Учет сопротивления воздуха является необходимым условием для получения точных результатов при решении прикладных задач.
Дальнейшее развитие модели может включать учет ветра, вращения Земли, изменения плотности воздуха с высотой, а также нестационарных эффектов в силе сопротивления.

<img width="1035" height="657" alt="image" src="https://github.com/user-attachments/assets/6345262a-8f0a-49e8-84be-00b5b62542c4" />


## Программная реализация

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

class BallisticModel:
    def __init__(self, mass=1.0, diameter=0.1, drag_coef=0.47, air_density=1.225, g=9.81):
        """
        Инициализация параметров модели
        
        Parameters:
        mass - масса тела, кг
        diameter - диаметр тела, м
        drag_coef - коэффициент лобового сопротивления
        air_density - плотность воздуха, кг/м³
        g - ускорение свободного падения, м/с²
        """
        self.mass = mass
        self.diameter = diameter
        self.drag_coef = drag_coef
        self.air_density = air_density
        self.g = g
        
        # Площадь поперечного сечения
        self.area = np.pi * (diameter/2)**2
        
        # Коэффициент сопротивления
        self.k = 0.5 * air_density * drag_coef * self.area
    
    def equations(self, t, state):
        """
        Система дифференциальных уравнений движения
        
        Parameters:
        t - время
        state - вектор состояния [x, y, vx, vy]
        
        Returns:
        производные [dx/dt, dy/dt, dvx/dt, dvy/dt]
        """
        x, y, vx, vy = state
        
        # Модуль скорости
        v = np.sqrt(vx**2 + vy**2)
        
        # Уравнения движения
        dxdt = vx
        dydt = vy
        dvxdt = -(self.k / self.mass) * vx * v
        dvydt = -self.g - (self.k / self.mass) * vy * v
        
        return [dxdt, dydt, dvxdt, dvydt]
    
    def solve_trajectory(self, v0, angle, t_max=10, dt=0.01):
        """
        Решение уравнений движения
        
        Parameters:
        v0 - начальная скорость, м/с
        angle - угол бросания, градусы
        t_max - максимальное время моделирования, с
        dt - шаг по времени, с
        
        Returns:
        t - массив времени
        trajectory - массив координат [x, y, vx, vy]
        """
        # Начальные условия
        angle_rad = np.radians(angle)
        vx0 = v0 * np.cos(angle_rad)
        vy0 = v0 * np.sin(angle_rad)
        initial_state = [0, 0, vx0, vy0]
        
        # Временной интервал
        t_span = (0, t_max)
        t_eval = np.arange(0, t_max, dt)
        
        # Решение системы ОДУ
        solution = solve_ivp(self.equations, t_span, initial_state, 
                           t_eval=t_eval, method='RK45')
        
        # Фильтрация точек после падения
        mask = solution.y[1] >= 0
        t = solution.t[mask]
        trajectory = solution.y[:, mask]
        
        return t, trajectory
    
    def calculate_characteristics(self, t, trajectory):
        """
        Расчет характеристик движения
        
        Returns:
        characteristics - словарь с характеристиками
        """
        x, y, vx, vy = trajectory
        
        flight_time = t[-1]
        max_range = x[-1]
        max_height = np.max(y)
        
        # Скорость в конечной точке
        final_speed = np.sqrt(vx[-1]**2 + vy[-1]**2)
        
        return {
            'flight_time': flight_time,
            'max_range': max_range,
            'max_height': max_height,
            'final_speed': final_speed
        }

# Параметры моделирования
model = BallisticModel(mass=0.1, diameter=0.05, drag_coef=0.47)

# Сравнение траекторий с сопротивлением и без
v0 = 50  # м/с
angle = 45  # градусы

# Траектория с сопротивлением
t_real, trajectory_real = model.solve_trajectory(v0, angle)

# Траектория без сопротивления (аналитическое решение)
t_ideal = np.linspace(0, 2*v0*np.sin(np.radians(angle))/model.g, 100)
x_ideal = v0 * np.cos(np.radians(angle)) * t_ideal
y_ideal = v0 * np.sin(np.radians(angle)) * t_ideal - 0.5 * model.g * t_ideal**2
y_ideal = np.where(y_ideal >= 0, y_ideal, 0)

# Характеристики движения
chars_real = model.calculate_characteristics(t_real, trajectory_real)
chars_ideal = {
    'flight_time': 2*v0*np.sin(np.radians(angle))/model.g,
    'max_range': v0**2 * np.sin(2*np.radians(angle))/model.g,
    'max_height': (v0*np.sin(np.radians(angle)))**2/(2*model.g),
    'final_speed': v0  # В идеальном случае скорость сохраняется
}

# Построение графиков
plt.figure(figsize=(12, 8))

# Траектории
plt.subplot(2, 2, 1)
plt.plot(trajectory_real[0], trajectory_real[1], 'b-', linewidth=2, label='С сопротивлением')
plt.plot(x_ideal, y_ideal, 'r--', linewidth=2, label='Без сопротивления')
plt.xlabel('Расстояние, м')
plt.ylabel('Высота, м')
plt.title('Сравнение траекторий')
plt.legend()
plt.grid(True, alpha=0.3)

# Горизонтальная скорость
plt.subplot(2, 2, 2)
plt.plot(t_real, trajectory_real[2], 'b-', linewidth=2, label='С сопротивлением')
plt.plot(t_ideal, v0*np.cos(np.radians(angle))*np.ones_like(t_ideal), 'r--', linewidth=2, label='Без сопротивления')
plt.xlabel('Время, с')
plt.ylabel('Vx, м/с')
plt.title('Горизонтальная скорость')
plt.legend()
plt.grid(True, alpha=0.3)

# Вертикальная скорость
plt.subplot(2, 2, 3)
plt.plot(t_real, trajectory_real[3], 'b-', linewidth=2, label='С сопротивлением')
vy_ideal = v0*np.sin(np.radians(angle)) - model.g*t_ideal
plt.plot(t_ideal, vy_ideal, 'r--', linewidth=2, label='Без сопротивления')
plt.xlabel('Время, с')
plt.ylabel('Vy, м/с')
plt.title('Вертикальная скорость')
plt.legend()
plt.grid(True, alpha=0.3)

# Полная скорость
plt.subplot(2, 2, 4)
v_real = np.sqrt(trajectory_real[2]**2 + trajectory_real[3]**2)
plt.plot(t_real, v_real, 'b-', linewidth=2, label='С сопротивлением')
plt.plot(t_ideal, v0*np.ones_like(t_ideal), 'r--', linewidth=2, label='Без сопротивления')
plt.xlabel('Время, с')
plt.ylabel('V, м/с')
plt.title('Полная скорость')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Вывод характеристик
print("ХАРАКТЕРИСТИКИ ДВИЖЕНИЯ:")
print(f"Начальные условия: v₀ = {v0} м/с, α = {angle}°")
print("\nС учетом сопротивления воздуха:")
print(f"Время полета: {chars_real['flight_time']:.2f} с")
print(f"Дальность полета: {chars_real['max_range']:.2f} м")
print(f"Максимальная высота: {chars_real['max_height']:.2f} м")
print(f"Конечная скорость: {chars_real['final_speed']:.2f} м/с")

print("\nБез учета сопротивления воздуха:")
print(f"Время полета: {chars_ideal['flight_time']:.2f} с")
print(f"Дальность полета: {chars_ideal['max_range']:.2f} м")
print(f"Максимальная высота: {chars_ideal['max_height']:.2f} м")
print(f"Конечная скорость: {chars_ideal['final_speed']:.2f} м/с")

print(f"\nСнижение дальности: {((chars_ideal['max_range'] - chars_real['max_range'])/chars_ideal['max_range']*100):.1f}%")
